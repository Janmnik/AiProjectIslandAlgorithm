package algortymGenetyczny;

import java.util.ArrayList;
import java.util.Arrays;
public class Algorytm {
	
	public double Ai;
	public double Bi;
	private double MutacjaPropability;
	private double krzyzowaniePropability;
	private double env;
	
	private int n, PopulacjaLength;
	private double precision;
	private int times;
	
	private static boolean firstRun = true;
	
	public Algorytm(double _Ai, double _Bi,double _precision,int _n,int _PopulacjaLength,double _env,double _MutacjaPropability, double _krzyzowaniePropability, int _times) {
		Ai = _Ai;
		Bi = _Bi;
		MutacjaPropability = _MutacjaPropability;
		krzyzowaniePropability = _krzyzowaniePropability;
		precision = _precision;
		PopulacjaLength = _PopulacjaLength;
		env = _env;
		n = _n;
		times = _times;
		
	}
	
	public void run(FunkcjaCeluZad1 goal) throws CloneNotSupportedException{
		
		//1 krok inicjalizacja poczatkowej populacji chromosomow
		//2 krok ocena przystosowania chromosomow w populacji
		//3 krok: selekcja choromosomow: ruletka
		//4 krok: zastpspwanie operatorow genetycznych
		//	mutowanie
		//	krzyzowanie
		//5 krok: stworzenie nowej popualcji
		
		Zapisywacz globalMaxes = new Zapisywacz(String.format("globalMAX%d .txt",PopulacjaLength));
		double AVGMAX [][] = new double[times][(int)(1000)];
		double AVGS[][] = new double[times][(int)(1000)];
		
		for(int i = 0 ; i < times; i++) {
			int generation  = 1;
			Czlonek baseChromosome = new Czlonek(Ai,Bi,n,precision);
			//krok 1 & 2
			Populacja populacja = new Populacja(baseChromosome,PopulacjaLength);
			populacja.adaptPopulacja(goal);	
			int j = 0;
			
			int adaptationNR = 0;
			
			while(adaptationNR < env) {
				//krok 3
				
				if(firstRun == true && adaptationNR % 20 == 0) {
					Zapisywacz adaptationSteps = new Zapisywacz(String.format("adaptationSteps%d .txt", PopulacjaLength));
					adaptationSteps.WriteToFile(String.format("%d", adaptationNR));
				}
				
				populacja = new Ruletka(populacja,"MAX").nowaPopulacja;
				AVGMAX[i][j] = populacja.Adaptation.MAX;
				AVGS[i][j] = populacja.Adaptation.AVG;
				//krok 4 & 5
				populacja = krzyzowanieChromosomes(populacja);
				populacja = mutatePopulacja(populacja);
				
				System.out.println("GENERACJA "+generation);
				generation++;
				populacja.Adaptation.showAdaptation();
				j++;
				adaptationNR++;	
			}
			firstRun = false;
			globalMaxes.WriteToFile(String.format("%g",populacja.GLOBALMAX));
		}
		
		Zapisywacz localMax = new Zapisywacz(String.format("localMax%d .txt",PopulacjaLength));
		Zapisywacz localAVG = new Zapisywacz(String.format("localAVG%d .txt",PopulacjaLength));
		double localMaxes[] =  calculateAVGLocal(AVGMAX);
		double localAVGS[] = calculateAVGLocal(AVGS);
		
		for(int i = 0; i < localMaxes.length;i++) {
			localMax.WriteToFile(String.format("%g", localMaxes[i]));
			localAVG.WriteToFile(String.format("%g", localAVGS[i]));
		}
	}
	
	
	private Populacja mutatePopulacja(Populacja populacja) {
		
		Mutacja mutacja = new Mutacja(MutacjaPropability);
		int length = populacja.Populacja.length;
		for(int i = 0; i < length;i++) {
			
			if(Math.random() < MutacjaPropability) {
				populacja.Populacja[i] = mutacja.czlonekMutacja(populacja.Populacja[i]);
			}
		}
		
		return populacja;
	}
	
	private Populacja krzyzowanieChromosomes(Populacja krzyzowaniePopulacja) throws CloneNotSupportedException {
		
		int randomChromosome;
		int chromosomeLength = krzyzowaniePopulacja.Populacja[0].getChromosomeLength();
		int length = krzyzowaniePopulacja.Populacja.length;
		double randomPropability = 0.0;
		
		Czlonek parentX,parentY;
		for(int i = 0;i<length;i++) {
			randomPropability = Math.random();
			if(randomPropability<=krzyzowaniePropability) {
				randomChromosome = (int)(Math.random()*length);
				Krzyzowanie2Punkt krzyzowanie2Punkt = new Krzyzowanie2Punkt(chromosomeLength);
				parentX = (Czlonek) krzyzowaniePopulacja.Populacja[i].clone();
				parentY = (Czlonek) krzyzowaniePopulacja.Populacja[randomChromosome].clone();
				krzyzowaniePopulacja.Populacja[i] = krzyzowanie2Punkt.getChild(parentX, parentY);
				krzyzowaniePopulacja.Populacja[randomChromosome] = krzyzowanie2Punkt.getChild(parentY, parentX);
			}
		}
		
		return krzyzowaniePopulacja;
	}
	
	
	private double[] calculateAVGLocal(double[][]arr) {
		double AVGLocalMAX [] = new double[times];
		for(int i = 0; i < times;i++) {
			AVGLocalMAX[i] = calculateAVG(arr[i]);
		}
		return AVGLocalMAX;
	}
	
	private double calculateAVG(double[] arr) {
		return Arrays.stream(arr).average().getAsDouble();
	}
	
	
}